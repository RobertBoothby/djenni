package com.robertboothby.djenni.core;

import java.util.function.Supplier;

/**
 * Wraps a {@link Supplier} of suppliers so the producing algorithm can be swapped out on demand. The first supplier is
 * obtained eagerly during construction and subsequent calls to {@link #renew()} refresh the delegate by invoking the
 * outer supplier again. This is useful for periodically refreshing cached data or rebuilding stateful suppliers between
 * test phases.
 * @param <T> The type being generated by the supplier.
 */
public class RenewableSupplier<T> implements StreamableSupplier<T> {

    private final Supplier<Supplier<T>> supplierSupplier;
    private Supplier<T> currentSupplier;

    /**
     * Create a renewable supplier that draws fresh delegate suppliers from {@code supplierSupplier}.
     * @param supplierSupplier factory returning new suppliers whenever a renewal is required
     */
    @SuppressWarnings("unchecked")
    public RenewableSupplier(Supplier<? extends Supplier<? extends T>> supplierSupplier) {
        this.supplierSupplier = (Supplier<Supplier<T>>) supplierSupplier;
        renew();
    }

    @Override
    public T get() {
        return currentSupplier.get();
    }

    /**
     * Replace the currently active supplier with a new instance from the original factory.
     */
    public void renew(){
        this.currentSupplier = supplierSupplier.get();
    }

    /**
     * Convenience factory for type inference.
     */
    public static <T> RenewableSupplier<T> renewable(Supplier< ? extends Supplier<? extends T>> supplierSupplier ) {
        return new RenewableSupplier<T>(supplierSupplier);
    }
}
