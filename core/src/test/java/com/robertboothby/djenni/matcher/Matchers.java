package com.robertboothby.djenni.matcher;

import com.robertboothby.djenni.distribution.Distribution;
import com.robertboothby.djenni.helper.DataCompletenessAssessment;
import org.hamcrest.Description;
import org.hamcrest.TypeSafeDiagnosingMatcher;

import java.util.Set;
import java.util.function.Supplier;

/**
 * This class produces matchers that are helpful in the testing of Suppliers and SupplierBuilders.
 * @author robertboothby
 */
public class Matchers {

    /**
     * Get a matcher that checks that a {@link Supplier} eventually supplies all the expected values and not any
     * unexpected ones.
     * @param values The full set of values that a supplier is expected to supply.
     * @param attempts The maximum number of times that values can be supplied attempting to match the expected values.
     * @param <T> The type of value being supplied.
     * @return the matcher.
     */
    public static <T> TypeSafeDiagnosingMatcher<Supplier<T>> eventuallySuppliesAllValues(
            final Set<T> values, final int attempts) {
        return new TypeSafeDiagnosingMatcher<Supplier<T>>() {

            @Override
            protected boolean matchesSafely(Supplier<T> supplier, Description mismatchDescription) {
                DataCompletenessAssessment<T, T> assessment = new DataCompletenessAssessment<>(
                        values, new DataCompletenessAssessment.IdentityDeriver<T>());
                for(int i = 0; i < attempts && !assessment.matchedSuccessfully(); i++){
                    T suppliedValue = supplier.get();
                    if(!assessment.attemptMatch(suppliedValue)){
                        mismatchDescription.appendText("Got unexpected value: ").appendValue(suppliedValue);
                        return false;
                    }
                }
                if(!assessment.matchedSuccessfully()){
                    mismatchDescription
                            .appendText("The following values remain: ")
                            .appendValue(assessment.getRemainingValuesToBeMatched());
                    return false;
                }
                return true;
            }

            public void describeTo(Description description) {
                description.appendText("To match all values: ").appendValue(values);
            }
        };
    }

    /**
     * Get a matcher that checks that a {@link com.robertboothby.djenni.distribution.Distribution} eventually generates all the expected values and not any
     * unexpected ones. This matcher is only practical when working with full ranges of smaller types or small ranges of
     * larger types.
     * @param values The full set of values that a generator is expected to generate.
     * @param bound the bound on the range of values to be generated.
     * @param attempts The maximum number of times that values can be generated attempting to match the expected values.
     * @param <T> The type of value being generated.
     * @return the matcher.
     */
    public static <T extends Number,U extends Number> TypeSafeDiagnosingMatcher<Distribution<T,U>> eventuallySuppliesAllValues(
            final Set<T> values, final U bound, final int attempts) {
        return new TypeSafeDiagnosingMatcher<Distribution<T, U>>() {

            public void describeTo(Description description) {
                description.appendText("To match all values: ").appendValue(values);
            }

            @Override
            protected boolean matchesSafely(Distribution<T, U> distribution, Description mismatchDescription) {
                DataCompletenessAssessment<T, T> assessment = new DataCompletenessAssessment<>(
                        values, new DataCompletenessAssessment.IdentityDeriver<T>());
                for(int i = 0; i < attempts && !assessment.matchedSuccessfully(); i++){
                    T generatedValue = distribution.generate(bound);
                    if(!assessment.attemptMatch(generatedValue)){
                        mismatchDescription.appendText("Got unexpected value: ").appendValue(generatedValue);
                        return false;
                    }
                }
                if(!assessment.matchedSuccessfully()){
                    mismatchDescription
                            .appendText("The following values remain: ")
                            .appendValue(assessment.getRemainingValuesToBeMatched());
                    return false;
                }
                return true;
            }
        };
    }

    /**
     * Get a matcher that looks at a derivative of the values generated by a Supplier and checks that a set of the
     * possible derivatives is eventually matched. A bit abstruse but to take a concrete example - we expect a Supplier
     * of Strings to generate random alphanumeric string between 5 and 10 characters long. To create a complete set of
     * possible values would be ridiculous and it would take a very long time to check. It is far more sensible to assert
     * based on derivatives of the generated Strings. So for example it is much easier to assert that for a given number
     * of attempts the full range of lengths would be generated and in a given number of attempts all the possible
     * characters would be used.
     * @param derivativeValues The set of derived values that we expect to get from the supplier.
     * @param deriver An object that derives a value from the supplied value that can usefully be asserted against.
     * @param attempts The maximum number of times that values can be supplied and derived, attempting to match the
     *                 expected values.
     * @param <T> The type of value being supplied.
     * @param <U> The type of the value being derived.
     * @return the matcher.
     */
    public static <U, T> TypeSafeDiagnosingMatcher<Supplier<T>> eventuallySuppliesAllDerivatives(
            final Set<U> derivativeValues, final DataCompletenessAssessment.Deriver<U,T> deriver, final int attempts) {
        return new TypeSafeDiagnosingMatcher<Supplier<T>>() {
            @Override
            protected boolean matchesSafely(Supplier<T> supplier, Description mismatchDescription) {
                DataCompletenessAssessment<U, T> assessment = new DataCompletenessAssessment<>(
                        derivativeValues, deriver);
                for(int i = 0; i < attempts && !assessment.matchedSuccessfully(); i++){
                    T generatedValue = supplier.get();
                    if(!assessment.attemptMatch(generatedValue)){
                        mismatchDescription
                                .appendText("Got unexpected value: ")
                                .appendValue(deriver.derive(generatedValue));
                        return false;
                    }
                }
                if(!assessment.matchedSuccessfully()){
                    mismatchDescription
                            .appendText("The following values remain: ")
                            .appendValue(assessment.getRemainingValuesToBeMatched());
                    return false;
                }
                return true;
            }

            public void describeTo(Description description) {
                description.appendText("To match all derived values: ").appendValue(derivativeValues);
            }
        };
    }
}
