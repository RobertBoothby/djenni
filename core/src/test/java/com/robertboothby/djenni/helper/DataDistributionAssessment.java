package com.robertboothby.djenni.helper;

import net.jcip.annotations.NotThreadSafe;
import org.djenni.Generator;
import org.djenni.distribution.Distribution;
import org.hamcrest.MatcherAssert;

import java.util.NavigableMap;
import java.util.TreeMap;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.Matchers.greaterThan;

/**
 * This class provides an assessment of the distribution of comparable data values.
 * <p>&#169; 2013 Forest View Developments Ltd.</p>
 * @author robertboothby
 * @param <T> The comparable type whose distribution is being assessed.
 */
@NotThreadSafe
public class DataDistributionAssessment<T extends Comparable<T>> {

    /**
     * The default number of samples that will be taken in order to build up the assessment.
     */
    public static final int DEFAULT_SAMPLE = 1000;

    // Could consider storing all the values as a list too, representing the sequence they were added.
    private NavigableMap<T, Integer> generatedValues = new TreeMap<T, Integer>();
    private int totalValues = 0;

    /**
     * Add another value to the distribution.
     * @param value the value to be added.
     */
    public void addValue(T value) {
        int timesSeen = 0;
        if(generatedValues.containsKey(value)){
            timesSeen = generatedValues.get(value) ;
        }
        generatedValues.put(value, timesSeen + 1);
        totalValues++;
    }

    /**
     * The proportion greater than or equal to the the value .
     * @param value the value to use in checking the proportion.
     * @return The proportion (as a fraction of 1.0D) of all the values that are greater than or equal to the value.
     */
    public double proportionGreaterThanOrEqualTo(T value) {
        if(value.compareTo(generatedValues.lastKey()) > 0) {
            return 0.0D;
        }
        final NavigableMap<T, Integer> greaterThanValues = generatedValues.subMap(value, true, generatedValues.lastKey(), true);
        int totalNumberOfEntries = 0;
        for(int numberOfEntries : greaterThanValues.values()){
            totalNumberOfEntries += numberOfEntries;
        }
        return ((double)totalNumberOfEntries)/totalValues;
    }

    /**
     * The proportion less than or equal to the the value .
     * @param value the value to use in checking the proportion.
     * @return The proportion (as a fraction of 1.0D) of all the values that are less than or equal to the value.
     */
    public double proportionLessThanOrEqualTo(T value) {
        if(value.compareTo(generatedValues.firstKey()) < 0) {
            return 0.0D;
        }
        final NavigableMap<T, Integer> lessThanValues = generatedValues.subMap(generatedValues.firstKey(), true, value, true);
        int totalNumberOfEntries = 0;
        for(int numberOfEntries : lessThanValues.values()){
            totalNumberOfEntries += numberOfEntries;
        }
        return ((double)totalNumberOfEntries)/totalValues;
    }

    /**
     * The proportion between the two values, inclusive of the first value, exclusive of the second.
     * @param bottomValue the bottom value (inclusive) of the range to be checked.
     * @param topValue the top value (exclusive) of the range to be checked.
     * @return The proportion (as a fraction of 1.0D) of all the values that are included in the range.
     * @throws AssertionError if the bottom value is greater than or equal to the top value.
     */
    public double proportionBetween(T bottomValue, T topValue){
        MatcherAssert.assertThat("The bottom value should be less than the top value", topValue, is(greaterThan(bottomValue)));
        final NavigableMap<T, Integer> boundedValues = generatedValues.subMap(bottomValue, true, topValue, false);
        int totalNumberOfEntries = 0;
        for(int numberOfEntries : boundedValues.values()){
            totalNumberOfEntries += numberOfEntries;
        }
        return ((double)totalNumberOfEntries)/totalValues;
    }

    /**
     * Get the greatest value in the data distribution.
     * @return the greatest value in the data distribution.
     */
    public T greatestValue() {
        return generatedValues.lastKey();
    }

    /**
     * Get the least value in the data distribution.
     * @return the least value in the data distribution.
     */
    public T leastValue() {
        return generatedValues.firstKey();
    }

    /**
     * Get the number of times the value occurs in the data distribution.
     * @param value The value for which to retrieve the count of occurrences.
     * @return The number of times the value appears.
     */
    public int count(T value) {
        Integer count = generatedValues.get(value);
        return count == null ? 0 : count;
    }

    /**
     * Create an assessment of the distribution of the values generated by a generator pf comparable values using the
     * {@link #DEFAULT_SAMPLE} number of samples.
     * @param generator The generator to assess.
     * @param <T> The type of value created by the generator - must be Comparable.
     * @return An instance of DataDistributionAssessment containing the results.
     */
    public static <T extends Comparable<T>> DataDistributionAssessment<T>  assessGenerator(Generator<T> generator) {
        return assessGenerator(generator, DEFAULT_SAMPLE);
    }

    /**
     * Create an assessment of the distribution of the values generated by a generator pf comparable values.
     * @param generator The generator to assess.
     * @param sampleSize the sample size to use for the assessment.
     * @param <T> The type of value created by the generator - must be Comparable.
     * @return An instance of DataDistributionAssessment containing the results.
     */
    public static <T extends Comparable<T>> DataDistributionAssessment<T>  assessGenerator(Generator<T> generator, int sampleSize) {
        DataDistributionAssessment<T> assessment = new DataDistributionAssessment<T>();
        for(int i = 0; i < sampleSize; i++) {
            assessment.addValue(generator.generate());
        }
        return assessment;
    }

    /**
     * Create an assessment of a distribution based on the bound using the {@link #DEFAULT_SAMPLE} of samples of
     * the {@link Distribution#generate(Number)} method.
     * @param distribution The distribution to assess
     * @param bound the bound to use when checking the distribution.
     * @param <T> The type of value that is generated by the distribution.
     * @param <U> The type of the bound that is used generating values.
     * @return An assessment of the distribution ready for assertion.
     */
    public static <T extends Number & Comparable<T>, U extends Number> DataDistributionAssessment<T> assessDistribution(Distribution<T, U> distribution, U bound){
        return gettDataDistributionAssessment(distribution, bound, DEFAULT_SAMPLE);
    }

    /**
     * Create an assessment of a distribution based on the bound using the requested number of samples of
     * the {@link Distribution#generate(Number)} method.
     * @param distribution The distribution to assess
     * @param bound the bound to use when checking the distribution.
     * @param sampleSize the number of samples to use when building the assessment.
     * @param <T> The type of value that is generated by the distribution.
     * @param <U> The type of the bound that is used generating values.
     * @return An assessment of the distribution ready for assertion.
     */
    public static <T extends Number & Comparable<T>, U extends Number> DataDistributionAssessment<T> gettDataDistributionAssessment(Distribution<T, U> distribution, U bound, int sampleSize) {
        DataDistributionAssessment<T> dataDistributionAssessment = new DataDistributionAssessment<T>();
        for(int i = 0; i < sampleSize; i++){
             dataDistributionAssessment.addValue(distribution.generate(bound));
        }
        return dataDistributionAssessment;
    }

}
