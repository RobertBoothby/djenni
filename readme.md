# Djenni -  Data Generation Framework
## Introduction
Djenni is the distillation of many years building diverse systems that all needed testing and, as a result, needed test data.
### Why Djenni?

<em>"The test outcome is often unaffected by the exact values of many of the inputs"</em>

There is an unstated assumption in most testing that the values of the uninteresting fields will not affect the result of
the test. In my experience this is usually a dangerous assumption.

### What does this mean?

In the majority of tests the point of the test is usually affected by one or two values. For example if we are testing
a validator that says verifies a vehicle is a bicycle only if it has two wheels then the color, the power-train and the
style of the frame should be irrelevant to validation. How do we prove that they are?

We should be able to put random values into the irrelevant data elements in a test and there should be no
change in outcome.

### What does Djenni do?
Djenni is designed to make it easy to set up test data for all types of testing and effectively assert which test data
is irrelevant to the outome and which data matters.

Djenni also makes it easy to generate large volumes of test data for rich domains and can scale well to support
everything from unit testing to large scale non-functional testing.

Djenni contains a Maven plugin that can generate a lot of the Suppliers and SupplierBuilders for your domain.

Djenni also contains a dynamically introspecting Supplier Builder that works best with classes that implement 
the JavaBeans getter and setter patterns.
```
        StreamableSupplier<TestClass> testClassSupplier = supplierFor(TestClass.class)
            .byGet(TestClass::getValueTwo, anyInteger().between(1).and(10))
            .byGet(TestClass::getValueOne, fix("One"))
            .bySet(TestClass::setValueThree, fix("Three"))
            .build();
        TestClass testClass = testClassSupplier.get();
        //OR Infinite stream
        Stream<TestClass> testClassStream = testClassSupplier.stream();
        //OR Stream of 10
        Stream<TestClass> testClassStreamOfTen = testClassSupplier.stream(10);
```

### The Core Pattern

Djenni is built around the concept of a &quot;Supplier&quot; and a &quot;SupplierBuilder&quot;.

The Supplier is the ultimate source of test data. Suppliers produce the objects required by the tests. These objects
are composed of other objects and, in the same way, most Suppliers are composed of other Suppliers. When a Supplier is used
to generate an object, it used other Suppliers to generate the object's fields which themselves may use other 
Suppliers and so on.

Suppliers should typically be immutable so that they are thread safe.

The SupplierBuilder makes it easy to configure and build instances of its associated Supplier. SupplierBuilders are 
mutable and are not thread safe.

Once you have used the SupplierBuilder to configure and build your Supplier, you can generate as many instances of
your test object as you want, usually on as many threads as you want. The Suppliers generated by this framework are
usually of type `StreamableSupplier` and so can easily be used to generate near endless quantities of data.

By implementing your own Suppliers and SupplierBuilders you can rapidly build up a data generation suite for your entire
domain that will make testing a lot easier.

## Quickstart

### Configure Build Tool
#### Maven:
```
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <!-- ... -->

    <build>
        <plugins>
            <!--
            Configure the compiler to produce class files with the parameter names preserved. This increases
            the size of the class files but allows the DynamicSupplierBuilder to automatically name the parameters.
            -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <compilerArgs>
                        <arg>-parameters</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <!-- ... -->

    <dependencies>
        <!--
        Core Djenni Dependency including the DynamicSupplierBuilder
        -->
        <dependency>
            <groupId>com.robertboothby.djenni</groupId>
            <artifactId>core</artifactId>
            <version>0.3.0</version>
        </dependency>
        <!-- ... -->
    </dependencies>
</project>
```
#### Gradle
```
   TBD
```

#### Intellij
To configure IntelliJ to compile with parameters add `-parameters` to the `Additional command line parameters` box in : `File -> Settings -> Build, Execution, Deployment  
-> Compiler -> Java Compiler`. You may need to add this to the sub-module configurations too.
### DynamicSupplierBuilder
```
import com.robertboothby.djenni.core.StreamableSupplier;

import static com.robertboothby.djenni.core.SupplierHelper.fix;
import static com.robertboothby.djenni.dynamic.DefaultSuppliers.defaultSuppliers;
import static com.robertboothby.djenni.dynamic.DynamicSupplierBuilder.supplierFor;
import static com.robertboothby.djenni.lang.IntegerSupplierBuilder.anyInteger;

//...

    //This will set up a default supplier for an and all int parameters using the primitive class type.
    defaultSuppliers().setClassSupplier(int.class, anyInteger().between(11).and(21).build());
    StreamableSupplier<TestClass> testClassSupplier = supplierFor(TestClass.class)
        .property(TestClass::getValueTwo, anyInteger().between(1).and(11))
        .property(TestClass::getValueOne, fix("One"))
        .property(TestClass::setValueThree, fix("Three"))
        .build();
    TestClass testClass = testClassSupplier.get();
```

